---
title: "WinAPI : UI & 장면 전환"
excerpt: "인터페이스 구성 및 출력"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-07-25
breadcrumb: true
---

# 41강. UI & 장면전환

## UI 설계

UI는 오브젝트중 하나라고 볼 수 있는데 정적인 UI도 있고, 동적인 UI도 존재한다. 

### UI 클래스

기본적으로 하위 인터페이스에 상속해주는 역할만 하고, 가상 함수로만 구성한다.

UI는 카메라에 절대 영향을 받아서는 안된다. 현재 다른 오브젝트나 배경 같은 경우 위치에 따라 자동으로 스크롤되도록 설계되어 있다. UI의 처리는 Obj의 렌더를 실행하지 않고 각자의 렌더를 실행하여 카메라 스크롤에 영향받지 않도록 해야한다. UI의 출력은 UI의 렌더에서 진행한다.

### 새로운 씬 StartScene + 매니저에 씬 추가

새로운 씬의 구조는 이전에 만들었던 InGameScene과 비슷하며, 해당 씬에는 UI Panel을 출력할 것이다.

```csharp
bool StartScene::Init()
{
	// 부모 Scene 클래스의 초기화 함수를 호출해준다.
	if (!Scene::Init())
		return false;

	Layer* pLayer = FindLayer("UI"); //UI 레이어를 받아옴.
	UIPanel* pBackPanel = Obj::CreateObj<UIPanel>("BackPanel", pLayer);

	pBackPanel->SetSize(GETRESOLUTION.iW, GETRESOLUTION.iH); // 해상도 받아옴
	pBackPanel->SetTexture("StartBack", L"StartBack.bmp");

	SAFE_RELEASE(pBackPanel);

	return true;
}
```

장면 관리자에서 해당 씬을 생성하고 현재 씬으로 지정한다.

```csharp
CreateScene<StartScene>(SC_CURRENT);
```

### UI 출력

UI의 출력은 오브젝트 렌더와 독립적으로 작동하지만 방식은 비슷하다. 단지 카메라 기능이 빠져있을뿐이다. UI에 출력되는 이미지도 애니메이션이 존재할 수 있기때문에 다른 기능은 그대로 둔다.

```csharp
void UI::Render(HDC hDC, float fDeltaTime)
{
	if (m_pTexture)
	{
		POSITION tImagePos;

		if (m_pAnimation)
		{
			PANIMATIONCLIP pClip = m_pAnimation->GetCurrentClip();

			if (pClip->eType == AT_ATLAS)
			{
				tImagePos.x = pClip->iFrameX * pClip->tFrameSize.x;
				tImagePos.y = pClip->iFrameY * pClip->tFrameSize.y;
			}
		}

		tImagePos += m_tImageOffset;

		if (m_pTexture->GetColorKeyEnable())
		{
			TransparentBlt(hDC, m_tPos.x, m_tPos.y, m_tSize.x, m_tSize.y,
				m_pTexture->GetDC(), tImagePos.x, tImagePos.y,
				m_tSize.x, m_tSize.y, m_pTexture->GetColorKey());
		}
		else
		{
			BitBlt(hDC, m_tPos.x, m_tPos.y, m_tSize.x, m_tSize.y,
				m_pTexture->GetDC(), tImagePos.x, tImagePos.y, SRCCOPY);
		}
	}
	list<Collider*>::iterator iter;
	list<Collider*>::iterator iterEnd = m_ColliderList.end();

	for (iter = m_ColliderList.begin(); iter != iterEnd;)
	{
		// 해당 충돌체가 비활성화 되어있다면 다음 충돌체 확인
		if (!(*iter)->GetEnable())
		{
			++iter;
			continue;
		}
		(*iter)->Render(hDC, fDeltaTime);

		// 해당 충돌체가 수명을 다하면
		if (!(*iter)->GetLife())
		{
			// 메모리 해제후 반복자 다시 지정
			SAFE_RELEASE((*iter));
			iter = m_ColliderList.erase(iter);
			iterEnd = m_ColliderList.end();
		}
		else
			++iter;
	}
}
```

![/assets/images/posts/2021-07-25/winapi41/Untitled.png](/assets/images/posts/2021-07-25/winapi41/Untitled.png)

정상적으로 출력이 된다.