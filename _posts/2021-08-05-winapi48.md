---
title: "WinAPI : 저장 & 불러오기"
excerpt: "다이얼로그를 이용한 맵 저장 불러오기"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-08-05
breadcrumb: true
---

# 48~50강. 파일 저장 및 불러오기

이전에 해본 맵 만들기의 결과물을 파일의 형태로 저장하고 불러올 수 있도록 해보자.

# 파일 저장 구조 설계

맵 에디터 씬에 파일 저장 및 불러오기에 사용할 키를 먼저 등록한다.

```csharp
GET_SINGLE(Input)->AddKey("Save", 'S', VK_CONTROL);
GET_SINGLE(Input)->AddKey("Load", 'O', VK_CONTROL);
// 조합 키로 등록되어 Ctrl + S, Ctrl + O의 효과를 낸다.

if (KEYDOWN("Save"))
{
	//해당 조합 키를 눌렀을 때 저장이 실행된다.
}
```

다이얼로그를 출력하여 원하는 파일 이름으로 저장할 수 있도록 할 것이다.

다이얼로그는 새로운 윈도우 창을 만드는 것이어서 기존에 존재하는 윈도우 핸들하고 전혀 다른 핸들이다.

프로젝트에서 리소스 추가를 선택해서 다이얼로그를 추가해준다. 해당 다이얼로그는 도구상자의 대화 상자 편집기에서 추가적인 컨트롤 목록이 나오는데 필요한 요소를 추가할 수 있다.

윈도우 프로시져를 이용해 다이얼로그를 열어서 확인을 해야하는데  방법은 크게 두가지 방법이 있다.

1. 모달 방식 : 다이얼로그를 열었을 때 부모 윈도우는 클릭이 불가능하다. (독점 모드)
2. 모달리스 방식 : 다이얼로그를 열었을 때 부모 윈도우도 클릭이 가능하다. (비 독점 모드)

### 다이얼로그 열기

저장 키를 누르게 될때 다이얼로그를 열게된다. DialogBox()를 이용해서 다이얼로그를 열 수 있다.

DialogBox의 인자로  다이얼로그의 ID값이 필요한데 프로젝트의 리소스 헤더에서 확인할 수 있다.

```csharp
DialogBox(WINDOWINSTANCE, MAKEINTRESOURCE(IDD_DIALOG1),
			WINDOWHANDLE, MapEditScene::DlgProc);
//인자로 윈도우 인스턴스, 다이얼로그 아이디 값, 윈도우 핸들, 다이얼로그 프로시져가 필요하다.
```

다이얼로그의 작동을 위해서는 DlgProc에 메세지를 만들어줘야 한다.

```csharp
INT_PTR MapEditScene::DlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		return TRUE;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			// Edit Box에서 문자열을 얻어온다.
			memset(m_strText, 0, sizeof(wchar_t) * MAX_PATH);
			GetDlgItemText(hWnd, IDC_EDIT1, m_strText, MAX_PATH);
		case IDCANCEL:
			EndDialog(hWnd, IDOK); // 다이얼로그 종료
			return TRUE;
		}
		return FALSE;
	}
	return FALSE;
}
```

오브젝트 클래스에 저장 - 불러오기 기능을 만들어야한다.

```csharp
  virtual void Save(FILE* pFile);
	virtual void Load(FILE* pFile);

	void SaveFromPath(const char* pFileName,const string& strPathKey = DATA_PATH);
	void LoadFromPath(const char* pFileName, const string& strPahtKey = DATA_PATH);
	void SaveFromFullPath(const char* pFullPath);
	void LoadFromFullPath(const char* pFullPath);
```

오브젝트의 자식 클래스에 속하는 StaticObj, Stage, Tile에도 해당 메소드를 추가해준다. 가상 함수는 자식의 것이 우선 순위로 실행되는 점을 사용하여 2, 3번만 자식 클래스에 추가한다.

```csharp
void Obj::Save(const char* pFileName, const string& strPathKey)
{
	//스테이지 저장
	const char* pPath = GET_SINGLE(PathManager)->FindPathMultiByte(DATA_PATH);
	string strFullPath;

	if (pPath)
		strFullPath = pPath;

	strFullPath += pFileName;

	SaveFromFullPath(strFullPath.c_str());
}

void Obj::SaveFromFullPath(const char* pFullPath)
{
	FILE* pFile = NULL;
	fopen_s(&pFile, pFullPath, "wb");

	if (pFile)
	{
		Save(pFile);

		fclose(pFile);
	}
}
```

위와 같은 형태로 함수 명만 바꾼상태에서 불러오기도 수행된다. ( Save → Load )

## 스테이지 저장

### 오브젝트 저장

저장이 실행될때 필요한 정보를 우선 고려해서 저장되는 파일에 같이 넣어줘야한다. 현재 Ref 클래스에 태그 정보가 들어있으므로 불필요한 오브젝트의 태그 정보는 빼주도록 하겠다.

```csharp
void Obj::Save(FILE* pFile)
{
	// 오브젝트 필수 요소 저장
	// Tag
	int iLength = m_strTag.length(); // 태그 길이 받아옴
	fwrite(&iLength, 4, 1, pFile); // 태그 길이 저장
	fwrite(m_strTag.c_str(), 1, iLength, pFile); // 태그 문자열 저장

	fwrite(&m_bIsPhysics, 1, 1, pFile); // 물리 효과 여부
	fwrite(&m_tPos, sizeof(m_tPos), 1, pFile); // 위치
	fwrite(&m_tSize, sizeof(m_tSize), 1, pFile); // 크기
	fwrite(&m_tImageOffset, sizeof(m_tImageOffset), 1, pFile);// 이미지 오프셋
	fwrite(&m_tPivot, sizeof(m_tPivot), 1, pFile); // Pivot
}
```

기본적인 오브젝트의 멤버 변수의 저장이다.

### 텍스쳐 저장

다음은 텍스쳐에 대한 부분인데 텍스쳐 클래스에 저장에 필요한 멤버변수를 추가해준다. 텍스쳐를 불러올때 저장된 텍스쳐를 다시 불러오기 위한 FileName, Key, PathKey가 이에 해당된다. 이 멤버변수들은 LoadTexture를 할때 저장하도록 한다.

```csharp
bool Texture::LoadTexture(HINSTANCE hInst, HDC hDC, const string& strKey, const wchar_t* pFileName, const string& strPathKey)
{
	// 텍스쳐 핵심 정보 지정
	m_strFileName = pFileName;
	m_strKey = strKey;
	m_strPathKey = strPathKey;
...
...
```

그리고 텍스쳐 클래스에 Save 메소드를 만들어 주는데 Obj 클래스의 Save 메소드에서 텍스쳐 클래스의 Save 메소드를 호출해 텍스쳐 정보를 저장한다.

```csharp
//텍스쳐 정보 저장
	bool bTexture = false;
	if (m_pTexture)
	{
		bTexture = true;
		fwrite(&bTexture,1, 1, pFile);
		m_pTexture->Save(pFile);
	}
	else
		fwrite(&bTexture, 1, 1, pFile);

// 텍스쳐가 있으면 있다는 정보를 저장, 없으면 없다는 정보를 저장.
```

```csharp
void Texture::Save(FILE* pFile)
{
	int iLength = m_strKey.length();
	// key의 길이 저장.
	fwrite(&iLength, 4, 1, pFile);
	fwrite(m_strKey.c_str(), 1, iLength, pFile);

	// FileName 저장
	iLength = m_strFileName.length();
	fwrite(&iLength, 4, 1, pFile);
	fwrite(m_strFileName.c_str(), 2, iLength, pFile);

	// PathKey 저장
	iLength = m_strPathKey.length();
	fwrite(&iLength, 4, 1, pFile);
	fwrite(m_strPathKey.c_str(), 1, iLength, pFile);

  // ColorKey 저장
	fwrite(&m_bColorKeyEnable, 1, 1, pFile);
	fwrite(&m_ColorKey, sizeof(COLORREF), 1, pFile);
}
```

### 충돌체 저장

오브젝트에 소속되어 있는 충돌체 정보에 대해서도 저장을 해야한다.