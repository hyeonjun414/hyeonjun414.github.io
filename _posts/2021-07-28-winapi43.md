---
title: "WinAPI : UI & 마우스2"
excerpt: "인터페이스 구성 및 출력"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-07-28
breadcrumb: true
---

# 43강. UI & 마우스2

## 마우스 충돌 처리

버튼은 사각형 충돌체를 가지고 있다. 마우스는 포인트 충돌체를 가지고 있어야 버튼과의 충돌을 처리할 수 있게된다.

### 포인트 충돌체

포인트 충돌체는 오브젝트가 가리키는 한 픽셀에서 충돌을 처리하는 방법을 사용한다. 다른 충돌체가 영역을 탐색하는 것과 달리 한 점에 대해서만 처리를 하면 되기에 연산량이 많지 않다.

```csharp
protected:
	POSITION m_tDist; // 오브젝트와의 거리
	POSITION m_tPos; // 실질적인 충돌체의 위치

public:
	POSITION GetPoint() const
	{
		return m_tPos;
	}

public:
	void SetDistance(float x, float y)
	{
		m_tDist.x = x;
		m_tDist.y = y;
	}
	void SetDistance(const POSITION& tDist)
	{
		m_tDist = tDist;
	}
```

한 점만 확인을 하기 때문에 크기는 필요없고 연결된 오브젝트와의 거리와 충돌체 자체의 위치만 고려하면 된다.

충돌체의 위치는 LateUpdate 부분에서 구해준다.

```csharp
int ColliderPoint::LateUpdate(float fDeltaTime)
{
	Collider::LateUpdate(fDeltaTime);

	POSITION tPos = m_pObj->GetPos();
	m_tPos.x = tPos.x + m_tDist.x;
	m_tPos.y = tPos.y + m_tDist.y;

	return 0;
}
```

포인트 충돌체는 앞서 만든 충돌체들과의 처리도 수행해야한다.

```csharp
// Rect - Point
bool Collider::CollisionRectToPoint(const RECTANGLE& src, const POSITION& dest)
{
	//Rect 안에 있는지 영역 탐색
	if (dest.x < src.l)
		return false;
	else if (dest.x > src.r)
		return false;
	else if (dest.y < src.t)
		return false;
	else if (dest.y > src.b)
		return false;

	return true;
}

// Sphere - Point
bool Collider::CollisionSphereToPoint(const SPHERE& src, const POSITION& dest)
{
	Math math;
	// 해당 포인트가 원 내부에 존재하는지 확인
	float fDist = math.Distance(dest, src.tCenter);
	return fDist <= src.fRadius;
}

// Pixel - Point
bool Collider::CollisionPixelToPoint(const vector<PIXEL>& vecPixel, int iWidth, int iHeight, const POSITION& dest)
{
	// 포인트의 좌표로 인덱스를 구할 수 있다.
	int idx =(int) dest.y * iWidth + (int)dest.x;
	const PIXEL& pixel = vecPixel[idx];
	// 해당 픽셀의 색상을 확인
	if (pixel.r == 255 && pixel.g == 0 && pixel.b == 255)
	{
		m_tHitPoint = dest;
		return true;
	}
	return false;
}
```

콜라이더에 해당 함수를 모두 구현했으면 각 충돌체마다 Point 충돌에 대한 충돌 함수를 추가해야한다.

```csharp
//Rect
case CT_POINT:
		return CollisionRectToPoint(m_tWorldInfo, ((ColliderPoint*)pDest)->GetPoint());
//Sphere
case CT_POINT:
		return CollisionSphereToPoint(m_tWorldInfo, ((ColliderPoint*)pDest)->GetPoint());
//Pixel
case CT_POINT:
		return CollisionPixelToPoint(m_vecPixel, m_iWidth, m_iHeight,
			((ColliderPoint*)pDest)->GetPoint());
```

그리고 Point 충돌체에도 마찬가지로 충돌처리를 한다.

```csharp
bool ColliderPoint::Collision(Collider* pDest)
{
	switch (pDest->GetColliderType())
	{
	case CT_RECT:
		return CollisionRectToPoint(((ColliderRect*)pDest)->GetWorldInfo(), m_tPos);
	case CT_SPHERE:
		return CollisionSphereToPoint(((ColliderSphere*)pDest)->GetWorldInfo(), m_tPos);
	case CT_PIXEL:
		return CollisionPixelToPoint(((ColliderPixel*)pDest)->GetPixel(), ((ColliderPixel*)pDest)->GetWidth(), 
			((ColliderPixel*)pDest)->GetHeight(), m_tPos);
	}
	return false;
}
```

### 포인트 충돌체 추가

만들어준 충돌체는 사용할 오브젝트인 마우스에도, 충돌 매니저에도 추가를 해야한다.

```csharp
// 마우스에 추가
ColliderPoint* pColl = AddCollider<ColliderPoint>("Mouse");
SAFE_RELEASE(pColl);

// 충돌 매니저에 추가
GET_SINGLE(CollisionManager)->AddObject(m_pMouse);
```

### 충돌 CallBack 함수

충돌처리를 위해서 마우스와 버튼 클래스에 Hit 함수를 만들어준다.

```csharp
void Hit(class COllider* pSrc, class Collider* pDest, float fDeltiTime);
```

현재 버튼 UI는 StartSecne에서 만들어주고 있다. 충돌체 설정하는 부분도 StartScene에서 처리를 하는데 추가적으로 충돌함수를 만들어줘야한다. 버튼에 마우스가 들어올때와 나갈때 수행하는 함수를 추가한다.

```csharp
void MouseOn(class Collider* pSrc, class Collider* pDest, float fDeltiTime);
void MouseOut(class Collider* pSrc, class Collider* pDest, float fDeltiTime);
```

버튼은 종류에 따라 다른 기능을 수행해야한다. Start 버튼은 무언가 시작을, End 버튼은 무언가 종료하는 것 처럼 말이다.

콜백 함수를 통해 함수를 설정하게된다.

```csharp
private:
	function<void(float fTime)> m_BtnCallback;
	bool		m_bEnableCallback; // CallBack이 활성화 되어있는지 확인하는 용도.

public:
	template<typename T>
	void SetCallback(T* pObj, void(T::* pFunc)(float))
	{
		m_BtnCallback = bind(pFunc, pObj, placeholders::_1);
		m_bEnableCallback = true;
	}

	void SetCallback(void(*pFunc)(float))
	{
		m_BtnCallback = bind(pFunc, placeholders::_1);
		m_bEnableCallback = true;
	}
```

아래와 같은 형태로 콜백 함수를 등록할 수 있다.

```csharp
pStartBtn->SetCallback(this, &StartScene::StartButtonCallback);
```