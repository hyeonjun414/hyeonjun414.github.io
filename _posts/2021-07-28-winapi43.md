---
title: "WinAPI : 버튼 충돌 및 장면 전환"
excerpt: "클릭과 장면전환"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-07-28
breadcrumb: true
---

# 43~44강. 버튼 충돌 및 장면 전환

## 마우스 충돌 처리

버튼은 사각형 충돌체를 가지고 있다. 마우스는 포인트 충돌체를 가지고 있어야 버튼과의 충돌을 처리할 수 있게된다.

### 포인트 충돌체

포인트 충돌체는 오브젝트가 가리키는 한 픽셀에서 충돌을 처리하는 방법을 사용한다. 다른 충돌체가 영역을 탐색하는 것과 달리 한 점에 대해서만 처리를 하면 되기에 연산량이 많지 않다.

```csharp
protected:
	POSITION m_tDist; // 오브젝트와의 거리
	POSITION m_tPos; // 실질적인 충돌체의 위치

public:
	POSITION GetPoint() const
	{
		return m_tPos;
	}

public:
	void SetDistance(float x, float y)
	{
		m_tDist.x = x;
		m_tDist.y = y;
	}
	void SetDistance(const POSITION& tDist)
	{
		m_tDist = tDist;
	}
```

한 점만 확인을 하기 때문에 크기는 필요없고 연결된 오브젝트와의 거리와 충돌체 자체의 위치만 고려하면 된다.

충돌체의 위치는 LateUpdate 부분에서 구해준다.

```csharp
int ColliderPoint::LateUpdate(float fDeltaTime)
{
	Collider::LateUpdate(fDeltaTime);

	POSITION tPos = m_pObj->GetPos();
	m_tPos.x = tPos.x + m_tDist.x;
	m_tPos.y = tPos.y + m_tDist.y;

	return 0;
}
```

포인트 충돌체는 앞서 만든 충돌체들과의 처리도 수행해야한다.

```csharp
// Rect - Point
bool Collider::CollisionRectToPoint(const RECTANGLE& src, const POSITION& dest)
{
	//Rect 안에 있는지 영역 탐색
	if (dest.x < src.l)
		return false;
	else if (dest.x > src.r)
		return false;
	else if (dest.y < src.t)
		return false;
	else if (dest.y > src.b)
		return false;

	return true;
}

// Sphere - Point
bool Collider::CollisionSphereToPoint(const SPHERE& src, const POSITION& dest)
{
	Math math;
	// 해당 포인트가 원 내부에 존재하는지 확인
	float fDist = math.Distance(dest, src.tCenter);
	return fDist <= src.fRadius;
}

// Pixel - Point
bool Collider::CollisionPixelToPoint(const vector<PIXEL>& vecPixel, int iWidth, int iHeight, const POSITION& dest)
{
	// 포인트의 좌표로 인덱스를 구할 수 있다.
	int idx =(int) dest.y * iWidth + (int)dest.x;
	const PIXEL& pixel = vecPixel[idx];
	// 해당 픽셀의 색상을 확인
	if (pixel.r == 255 && pixel.g == 0 && pixel.b == 255)
	{
		m_tHitPoint = dest;
		return true;
	}
	return false;
}
```

콜라이더에 해당 함수를 모두 구현했으면 각 충돌체마다 Point 충돌에 대한 충돌 함수를 추가해야한다.

```csharp
//Rect
case CT_POINT:
		return CollisionRectToPoint(m_tWorldInfo, ((ColliderPoint*)pDest)->GetPoint());
//Sphere
case CT_POINT:
		return CollisionSphereToPoint(m_tWorldInfo, ((ColliderPoint*)pDest)->GetPoint());
//Pixel
case CT_POINT:
		return CollisionPixelToPoint(m_vecPixel, m_iWidth, m_iHeight,
			((ColliderPoint*)pDest)->GetPoint());
```

그리고 Point 충돌체에도 마찬가지로 충돌처리를 한다.

```csharp
bool ColliderPoint::Collision(Collider* pDest)
{
	switch (pDest->GetColliderType())
	{
	case CT_RECT:
		return CollisionRectToPoint(((ColliderRect*)pDest)->GetWorldInfo(), m_tPos);
	case CT_SPHERE:
		return CollisionSphereToPoint(((ColliderSphere*)pDest)->GetWorldInfo(), m_tPos);
	case CT_PIXEL:
		return CollisionPixelToPoint(((ColliderPixel*)pDest)->GetPixel(), ((ColliderPixel*)pDest)->GetWidth(), 
			((ColliderPixel*)pDest)->GetHeight(), m_tPos);
	}
	return false;
}
```

### 포인트 충돌체 추가

만들어준 충돌체는 사용할 오브젝트인 마우스에도, 충돌 매니저에도 추가를 해야한다.

```csharp
// 마우스에 추가
ColliderPoint* pColl = AddCollider<ColliderPoint>("Mouse");
SAFE_RELEASE(pColl);

// 충돌 매니저에 추가
GET_SINGLE(CollisionManager)->AddObject(m_pMouse);
```

### 충돌 CallBack 함수

충돌처리를 위해서 마우스와 버튼 클래스에 Hit 함수를 만들어준다.

```csharp
void Hit(class COllider* pSrc, class Collider* pDest, float fDeltiTime);
```

현재 버튼 UI는 StartSecne에서 만들어주고 있다. 충돌체 설정하는 부분도 StartScene에서 처리를 하는데 추가적으로 충돌함수를 만들어줘야한다. 버튼에 마우스가 들어올때와 나갈때 수행하는 함수를 추가한다.

```csharp
void MouseOn(class Collider* pSrc, class Collider* pDest, float fDeltiTime);
void MouseOut(class Collider* pSrc, class Collider* pDest, float fDeltiTime);
```

버튼은 종류에 따라 다른 기능을 수행해야한다. Start 버튼은 무언가 시작을, End 버튼은 무언가 종료하는 것 처럼 말이다.

콜백 함수를 통해 함수를 설정하게된다.

```csharp
private:
	function<void(float fTime)> m_BtnCallback;
	bool		m_bEnableCallback; // CallBack이 활성화 되어있는지 확인하는 용도.

public:
	template<typename T>
	void SetCallback(T* pObj, void(T::* pFunc)(float))
	{
		m_BtnCallback = bind(pFunc, pObj, placeholders::_1);
		m_bEnableCallback = true;
	}

	void SetCallback(void(*pFunc)(float))
	{
		m_BtnCallback = bind(pFunc, placeholders::_1);
		m_bEnableCallback = true;
	}
```

아래와 같은 형태로 콜백 함수를 등록할 수 있다.

```csharp
pStartBtn->SetCallback(this, &StartScene::StartButtonCallback);
```

## 버튼 충돌 처리

### 버튼 상태 설정 및 변경

버튼에서 클릭되는 부분은 MouseOn 상태에서만 실행되어야 한다. 버튼의 헤더 부분에 현 상태를 저장하는 변수를 만들어주자.

```csharp
// 버튼 상태를 알리는 열거형 변수
enum BUTTON_STATE
{
	BS_NONE,
	BS_MOUSEON,
	BS_CLICK
};

BUTTON_STATE m_eState;
```

 함수가 작동하면 충돌한 오브젝트가 마우스인지 확인하고 상황에 맞게 상태를 변경해준다.

```csharp
void UIButton::MouseOn(Collider* pSrc, Collider* pDest, float fDeltiTime)
{
    if (pDest->GetTag() == "Mouse")
        m_eState = BS_MOUSEON;
}

void UIButton::MouseOut(Collider* pSrc, Collider* pDest, float fDeltiTime)
{
    if (pDest->GetTag() == "Mouse")
        m_eState = BS_NONE;
}
```

### 마우스 우클릭 확인

마우스의 클릭은 Update에서 일어나니 LateUpdate에서 확인을 한다. 해당 클릭 처리는 버튼이 MOUSEON 상태일 때만 처리해줘야한다. Input 클래스에서 마우스 L버튼에 대해서 추가를 해둔 상태이다.

```csharp
int UIButton::LateUpdate(float fDeltaTime)
{
    UI::LateUpdate(fDeltaTime);
    // 버튼 상태가 MOUSEON 상태일 때
    if (m_eState != BS_NONE)
    {
        // 좌클릭이 되고 있음을 확인
        if (KEYPRESS("MouseLButton"))
        {
            m_eState = BS_CLICK;
        }
    }
    // 클릭했다가 때었을때
    if (m_eState == BS_CLICK && KEYUP("MouseLButton"))
    {
        // 콜백 함수가 활성화 되어있을때
        if (m_bEnableCallback)
        {
            m_BtnCallback(fDeltaTime);
        }
    }
    return 0;
}
```

### 버튼 상태에 따른 이미지 변경

상태에 따라 이미지 오프셋을 조절하여 다른 이미지를 출력하도록 해줄 것이다.

```csharp
int UIButton::LateUpdate(float fDeltaTime)
{
    UI::LateUpdate(fDeltaTime);
    // 버튼 상태가 MOUSEON 상태일 때
    if (m_eState != BS_NONE)
    {
        // 좌클릭이 되고 있음을 확인
        if (KEYPRESS("MouseLButton"))
        {
            m_eState = BS_CLICK;
            SetImageOffset(m_tSize.x * 2.f, 0.f); //오프셋 변경

        }
    }
    // 클릭했다가 때었을때
    if (m_eState == BS_CLICK && KEYUP("MouseLButton"))
    {
				// 상태 변경 및 이미지 오프셋 변경
        m_eState = BS_MOUSEON;
        SetImageOffset(m_tSize.x, 0.f);
        // 콜백 함수가 활성화 되어있을때
        if (m_bEnableCallback)
            m_BtnCallback(fDeltaTime);
    }
    return 0;
}

void UIButton::MouseOn(Collider* pSrc, Collider* pDest, float fDeltiTime)
{
    if (pDest->GetTag() == "Mouse")
    {
        m_eState = BS_MOUSEON;
        SetImageOffset(m_tSize.x, 0.f);
    }
}

void UIButton::MouseOut(Collider* pSrc, Collider* pDest, float fDeltiTime)
{
    if (pDest->GetTag() == "Mouse")
    {
        m_eState = BS_NONE;
        SetImageOffset(0.f, 0.f);
    }
}
```

### 버튼 클릭으로 장면전환