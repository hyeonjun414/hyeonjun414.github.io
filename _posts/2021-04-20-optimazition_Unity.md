---
title: "Game : 각종 최적화 기법"
excerpt: "여러 최적화 방법"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - Game
tags:
  - [Unity, Design, 최적화]
date: 2021-04-20
breadcrumb: true
---


# 유니티 : 각종 최적화 기법

## 오브젝트 풀링(Object Pooling)

짧게 사용되고 사라진 뒤에 다시 사용되는 오브젝트의 경우 매 번 다시 생성/해제를 반복하면 메모리 부하가 심해진다.

그래서 화면에만 보이지 않게만 하고 해제시키지 않은 채로 필요할때 가져와 사용하는 방법을 사용하는데 그것이 오브젝트 풀링이다.

메모리 할당을 더 간단하게 할 수 있고 동적 메모리 할당 오버헤드와 가비지 컬렉션을 줄일 수 있다.

하지만 단점도 존재한다.

1. 다른 목적으로 사용할 가용 힙 메모리의 양이 줄어든다. 따라서 현쟂 막 생성한 풀 외에도 메모리를 계속 할당한다면, 가비지 컬렉션이 더 자주 실행된다.
2. 가비지 컬렉션에 걸리는 시간은 살아있는 오브젝트 수에 비례하여 증가하기 때문에 매번 더 느려질 수 있다.
3. 너무 큰 풀을 할당하거나 또는 풀에 있는 오브젝트가 한동안 필요가 없는 상황에서 풀을 활성화하여 유지한다면 성능에 지장이 생기게 된다.

따라서 "오브젝트 풀 오버헤드 < 오브젝트 풀을 사용하지 않았을 때 생기는 메모리 부하"인 경우에만 사용 해야 한다.

## Class vs Struct

클래스의 인스턴스는 힙 영역에, 구조체의 인스턴스는 스택에 할당된다.

즉, 구조체는 아무리 만들고 없애도 가비지 컬랙터에 부담을 주지 않지만 클래스를 반복적으로 할당 해제하는 것은 가비지 컬랙터에 부담을 주게 된다.

장시간 유지되어야하는 오브젝트는 클래스에, 단시간만 사용할 오브젝트는 구조체에 사용해주는 것이 좋다.

메소드에서 반복적으로 생성이 필요한 사용자 정의 테이블을 만들때는 구조체 형식을 사용해야할 것같다.

## Immutable, String 반복 생성

```csharp
//<리스트 1> ‘+’로 연결한 문자열 조합
class Names
{
    public string[] name = new string[100];
    public void Print()
    {
        for (int index = 0; index < name.Length; index++)
        {
            string output = "[" + index + "]" + name;
            Console.WriteLine(output);
        }
    }
}
```

C#에서 String은 Immutable 객체다. 따라서 "안녕" + "하세요" 를 연산하면 새로운 안녕하세요 객체를 생성하게 된다. 하지만 이경우 반복문 안에서 객체의 할당과 해제가 수차례 발생하게되고 메모리 단편화 문제가 발생한다.

```csharp
//<리스트 2> System.Text.StringBuilder 객체 사용
class NewNames
{
    public string[] name = new string[100];
    private StringBuilder sb = new StringBuilder();
    public void Print()
    {
        sb.Clear();     // sb.Length = 0;
        for (int index = 0; index < name.Length; index++)
        {
            sb.Append("[");
            sb.Append(index);
            sb.Append("] ");
            sb.Append(name);
            sb.AppendLine();
        }
        Console.WriteLine(sb.ToString());
    }
}
```

위와 같이 StringBuilder를 이용해 Append()메소드를 통해 문자열을 추가하며 string객체를 만들어내는 것이 아니라 이미 잡아놓은 메모리 공간에 문자열만 복사하여 한번에 ToString()으로 string객체를 생성한다.

내부의 for문은 다음과 같이 정리할 수도 있다.

```csharp
for (int index = 0; index < name.Length; index++)
{
    sb.AppendFormat("[{0}] {1}", index, name.ToString());
}
```

## 애니메이션 스프라이트 파티클 시스템

횡스크롤 게임에서 수많은 동전이 떨어지고 튕기고 회전하는 효과를 표현하려고 한다. 동전은 점 광원에 의해 동적으로 빛난다.

하드웨어가 고성능이라면 모든 동전을 오브젝트로 만들고, 버텍스 릿, 포워드 또는 디퍼드 라이팅 중에 하나를 가지고 셰이드하고, 이미지 이펙트로 상단에 글로우 효과를 추가해 밝게 반사하는 동전이 주변에 광원을 뿌리도록 하면된다.

하지만 모바일 하드웨어의 경우 이 방법은 크게 부담이 되고 불가능하다.

요점은 동전의 회전등을 물리적으로 구현하는것이 아니라 물리적 구현의 결과를 미리 계산하여 그것을 스프라이트 파티클로 대체하는 것이다. 이 때, 모든 동전이 단조롭게 움직이는 것을 방지하기 위해 회전과 수명 주기를 직접 추적하고 파티클 수명 주기에 맞춰 회전을 렌더링하는 방식을 사용해야 한다.

동적으로 그림자를 생성하는 것은 위험하다.

## 불필요한 검색 대신 캐시 레퍼런스 사용

오브젝트를 메소드 안에어 반복 생성하지 말고 자주 쓸 것 같으면 멤버 변수로 한번 기억을 시켜놓고 메소드에서는 멤버 변수를 호출해서 사용하라는 뜻이다. 

## 비용이 큰 수학 연산 줄이기

Sin, pow, 나눗셈, 제곤근, 루트 등의 연산이 곱셈 연산보다 100배 느리다고 한다.

예를 들어 메소드에서 변수/멤버상수 인경우 1.0/C 를 미리 기억 했다가 곱셈연산으로 바꾸는 편이 좋다는 이야기다.

다른 예로는 벡터 정규화 등이 있다. 캐싱을 하거나 nomalized 프로 퍼티 대신 역을 곱한다거나 하는 방식이 있다.

거기에 Math 함수들은 어쨌든 함수가 호출되는 것으로 오버헤드가 발생한다. 간단한 계산은 코드 내에서 처리하는 것이 좋다.