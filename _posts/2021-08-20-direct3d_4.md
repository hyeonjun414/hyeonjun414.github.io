---
title: "Direct3D : Direct3D의 초기화"
excerpt: "기본 지식"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - Direct3D
tags:
  - [CPP, Direct3D]
date: 2021-08-20
breadcrumb: true
---

# 4.1. Direct3D의 초기화

## 4.1 Direcr3D의 기본 지식

Direct3D 초기화 공정에 앞서서 기본적인 그래픽 개념과 Direct3D 형식들을 알아보자.

### 4.1.1 Direct3D 12의 개요

 Direct3D는 GPU를 제어하고 프로그래밍하는 데 사용되는 저수준 그래픽 API이다. 이를 통해 응용 프로그램은 3차우너 그래픽 가속 기능을 이용해서 3차원 세계를 렌더링 할 수 있게 된다. 응용 프로그램과 그래픽 하드웨어 사이에 Direct3D라는 간접층과 하드웨어 드라이버가 Direct3D 명령들을 시스템의 GPU가 직접 이해하는 고유한 기계어 명령들로 번역해줘서 사용하는 GPU가 다이렉트X를 지원하는 이상, 응용 프로그램 개발자는 GPU의 세부사항을 고려할 필요가 없다.

 Direct3D 12는 이전 버전에 비해서 훨씬 낮은 수준의 API가 되었으면, 추상화가 더 줄어들게되고 개발자가 손수 관리해야 할 사항들이 늘어났으며, GPU 구조에 더 밀접하게 반영한다. API 사용 난이도는 올라갔지만 성능이 더 개선된 셈이다.

### 4.1.2 COM

 COM(Component Object Model)은 다이렉트X의 프로그래밍 언어 독립성과 하위 호환성을 가능하게 하는 기술 이다. COM 객체를 흔히 COM 인터페이스라고 부르지만, C++ 클래스로 간주하고 사용해도 무방하다. 프로그래머가 사용하는 부분은 필요한 COM 인터페이스를 가리키는 포인터를 특별한  함수를 사용하거나, 다른 COM 인터페이스의 메서드를 이용해서 얻는 방법뿐이다. 또한 COM 인터페이스를 C++의 new 키워드로 생성할 필요가 없고, 사용한 이후에는 Release를 통해 메모리를 해제 시켜줘야한다.

 COM 객체의 수명관리를 돕기 위해, Windows 런타임 라이브러리는 ComPtr이라는 클래스를 제공한다. 이 클래스는 COM 객체를 위한 똑똑한 포인터라 할 수 있다. 범위를 벗어난 ComPtr 인스턴스는 바탕 COM 객체에 대해 자동으로 Release를 호출하여 프로그래머가 따로 호출할 필요가 없다.

 주로 사용하는 ComPtr의 메서드는 아래 세 가지 이다.

 

1. Get : 바탕 COM 인터페이스를 가리키는 포인터를 돌려준다. 해당 COM 인터페이스 포인터 형식의 인수를 받는 함수를 호출할 때 흔히 쓰인다.
2. GetAddressOf : 바탕 COM 인터페이스를 가리키는 포인터의 주소를 돌려준다. 함수 매개변수를 통하여 COM 인터페이스 포인터를 돌려받을 때 흔히 쓰인다. 
3. Reset : ComPtr 인스턴스를 nullptr로 설정하고 COM 인터페이스의 참조 횟수를 1 감소시킨다. 

### 4.1.3 텍스쳐 형식

 2차원 텍스쳐는 자료 원소들의 행렬(2차원 배열)이다. 2차원 텍스처에서 텍스처의 각 원소는 픽셀 하나의 색상을 담는다. 다른 용도도 존재하는데 예를  들어 법선 매핑이라고 하는 고급 기법에서는 텍스처의 각원소가 색상이 아니라 3차원 벡터를 담는다. 

 사실 텍스처가 단순한 자료 배열인 것만은 아니다. 텍스처에 밉맵 수준들이 존재할 수 있으며, GPU는 필터링, 다중표본화 등의 특별한 연산을 텍스처에 적용할 수 있다. 더 나아가, 텍스처에 아무 자료나 담을 수 있는 것은 아니라는 점도 중요하다. 텍스처에는 특정 형식의 자료원소들만 담을 수 있는데, 구체적인 형식은 DXGI_FORMAT이라는 열거형으로 지정한다. 다음은 텍스처에 담을 수 있는 자료 원소 형식의 예이다.

1. DXGI_FORMAT_R32G32B32_FLOAT : 각 원소는 32비트 부동소수점 성분 세 개로 이루어진다.
2. DXGI_FORMAT_R16G16B16A16_UNORM : 각 원소는[0, 1] 구간으로 사상되는 16비트 성분 네 개로 이루어진다. 
3. DXGI_FORMAT_R32G32_UNIT : 각 원소는 부호 없는 32비트 정수 성분 두 개로 이루어진다.
4. DXGI_FORMAT_R8G8B8A8_UNORM : 각 원소는[0, 1] 구간으로 사상되는 부호 없는 8비트 성분 네 개로 이루어 진다.
5. DXGI_FORMAT_R8G8B8A8_SNORM : 각 원소는 [-1, 1] 구간으로 사상되는 부호 있는 9비트 성분 네 개로 이루어진다.
6. DXGI_FORMAT_R8G8B8A8_SINT : 각 원소는 [-128, 127] 구간으로 사상되는 부호 있는 9비트 정수 성분 네 개로 이루어진다.
7. DXGI_FORMAT_R8G8B8A8_UINT : 각 원소는 [0, 255] 구간으로 사상되는 부호 없는 9비트 정수 성분 네 개로 이루어진다.

 여기서 R, G, B, A는 각각 적, 녹, 청, 알파 성분을 뜻한다. 하나의 색상은 RGB로 이루어지고 A는 일반적으로 투명도를 제어하는데 사용된다.  그러나 앞서 말했듯이 텍스처에 반드시 색상만 들어가는 것은 아니다. 부동소수점 성분 세 개로 구성되는 DXGI_FORMAT_R32G32B32_FLOAT에 임의의 3차원 벡터를 담을 수도 있다. 

 무형식(typeless) 텍스처들도 있는데, 이런 텍스처는 일단 메모리만 확보해 두고 자료의 구체적인 해석 방식은 나중에 텍스처를 파이프라인에 묶을 때 지정하는 용도로 사용된다. 무형식 텍스쳐 형식은 원소마다 16비트 성분 네 개를 할당하되, 각 16비트 성분의 구체적인 자료 형식은 지정하지 않는다.

### 4.1.4 교환 사슬과 페이지 전환

 애니메이션이 깜박이는 현상을 피하려면 다음과 같은 방법을 사용하는 것이 좋다.

- 우선, 애니메이션의 한 프레임 전체를 화면 바깥의(off-screen) 텍스처에 그린다. 이 텍스처를 후면 버퍼(back buffer)라고 한다.
- 후면 버퍼에 주어진 한 프레임을 위한 장면 전체를 그린 다음, 하나의 완전한 프레임으로서 화면에 표시한다. 이런 방법을 사용하여 그려지는 과정이 나타나지 않도록 한다.

이러한 방법을 이중 버퍼링이라고 하는데 효율적인 이중 버퍼링을 위해 두 개의 텍스쳐 버퍼, 전면버퍼와 후면 버퍼가 필요하다. 화면에는 전면 버퍼에 담긴 이미지 자료가 표시되고 전면 버퍼가 화면에 표시된 동안 애니메이션의 다음 프레임을 후면 버퍼에 그리고 역할을 교체하는 방식을 사용한다. 이처럼 후면 버퍼와 전면 버퍼의 역할을 교환하여 페이지가 전환되게 하는 것을 Direct3D에서는 제시(presenting)라고 한다.  제시는 버퍼의 내용 자체를 바꾸는 것이 아니라 두 버퍼의 포인터만 맞바꾸면 되기 때문에 매우 효율적이다.

 전면 버퍼와 후면 버퍼는 하나의 교환 사슬(swap chain)을 형성한다. Direct3D에서 교환 사슬을 대표하는 인터페이스는 IDXGISwapChain이다. 이 인터페이스는 전면 버퍼 텍스처와 후면 버퍼 텍스처를 담으며, 버퍼 크기 변경을 위한 메서드(ResizeeBuffers)와 버퍼의 제시를 위한 메서드(Present)도 제공한다.

### 4.1.5 깊이 버퍼링

깊이 버퍼(depth buffer)는 이미지 자료를 담지 않는 텍스처의 한 예이다. 깊이 버퍼는 각 픽셀의 깊이 정보를 담는다. 픽셀의 깊이는 0.0에서 1.0까지의 값으로, 0.0은 시야 절두체(view frustum) 안에서 관찰자에 최대한 가까운 물체에 해당하고 1.0은 시야 절두체 안에서 관찰자와 최대한 먼 물체에 해당한다. 깊이 버퍼의 원소들과 후면 버퍼의 픽셀들은 이대일로 대응된다. 후면 버퍼의 해상도와 깊이 버퍼의 해상도는 일치된다.

 한 물체의 픽셀들이 다른 물체보다 앞에 있는지 판정하기 위해, Direct3D는 깊이 버퍼링 또는 z-버퍼링이라는 기법을 사용한다. 여기서 중요한 점은, 깊이 버퍼링을 이용하면 물체들을 그리는 순서와 무관 하게 물체들이 제대로 가려진다는 것이다. 픽셀과 해당 깊이 값은 그 깊이 값이 깊이 버퍼에 이미 들어 있던 값보다 작은 경우에만 후면 버퍼와 깊이 버퍼에 기록된다. 이런 방식에서는 항상 관찰자에 가장 가까운 픽셀이 렌더링 된다.

 정리하자면, 깊이 버퍼링 알고리즘은 렌더링 되는 각 픽셀의 깊이 값을 계산해서 깊이 판정을 수행함으로써 작동된다. 깊이 판정은 후면 버퍼의 특정 픽셀 위치에 기록될 픽셀들의 깊이들을 비교한다.

 깊이 버퍼는 하나의 텍스처이므로, 생성 시 특정한 자료 원소 형식을 지정할 필요가 있다.  깊이 버퍼링을 위한 텍스처 자료 원소 형식으로는 다음과 같은 것들이 있다.

1. DXGI_FORMAT_D32_FLOAT_S8X24_UNIT : 각 텍셀은 32비트 부송소수점 깊이 값과 [0, 255] 구간으로 사상되는 부호 없는 8비트 정수 스텐실 값, 채우는 용도로 사용되는 24비트로 구성된다.
2. DXGI_FORMAT_D32_FLOAT : 각 텍셀은 하나의 32비트 부동소수점 깊이 값이다.
3. DXGI_FORMAT_D24_UNORM_S8_UINT : 각 텍셀은 [0, 1] 구간으로 사상되는 부호 없는 24비트 깊이 값 하나와 [0, 255] 구간으로 사상되는 부호 없는 8비트 정수 스텐실 값으로 구성된다.
4. DXGI_FORMAT_D16_UNORM : 각 텍셀은 [0, 1] 구간으로 사상되는 부호 없는 16비트 깊이 값이다.

### 4.1.6 자원과 서술자

 렌더링 과정에서 GPU는 자원들에 자료를 기록하거나 자원들에서 자료를 읽어 들인다. 그리기 명령을 제출하기 전에, 먼저 해당 그리기 호출이 참조할 자원들을 렌더링 파이프라인에 묶어야(bind) 한다. 이를 가리켜 자원을 파이브라인에 연결 또는 바인딩한다 라고 말한다. 그리기 호출마다 달라지는 자원들도 있으며, 그런 자원들의 바인딩을 갱신해야한다. 그런데 GPU자원들이 파이프라인에 직접 묶이는 것은 아니고 대신 해당 자원을 참조하는 서술자(descriptor) 객체가 묶인다. 

 서술자 객체는 자원을 GPU에게 서술해주는 경량의 자료구조라고 할 수 있다. 본질적으로 이는 하나의 간접층이다. GPU는 자원 서술자를 통해 실제 자료에 접근하며, 그 자료를 사용하는데 필요한 정보 역시 자원 서술자로부터 얻는다. 그리기 호출이 참조할 서술자들을 명시하면 해당 자원들이 렌더링 파이프라인에 묶인다.

 이런 추가적인 간접층을 두는 이유는, GPU 자원이 사실상 범용적인 메모리 조각이기 때문이다. 자원은 범용적이므로, 같은 자원을 렌더링 파이프라인의 서로 다른 단계에서 사용할 수 있다. 자원 자체는 자신이 어떤 역할로 쓰여야하는지 말을 하지 않고, 자원에는 파이프라인의 정보가 없고 파이프라인에는 자원에 형식을 알 수 없다. 이런 문제를 해결해주는 것이 서술자이다. 서술자는 양측에 서로에 대한 정보를 서술하는 수단이기도 하다.

 서술자는 자원의 사용법에 따라 여러 종류가 있다.

1. CBV/SRV/UAV 서술자들은 각각 상수 버퍼, 셰이더 자원, 순서 없는 접근을 서술한다.
2. 표본추출기 서술자는 텍스처 적용에 쓰이는 표본추출기 자원을 서술한다.
3. RTV 서술자는 렌더 대상 자원을 서술한다.
4. DSV 서술자는 깊이-스텐실 자원을 서술한다.

 서술자 힙은 서술자들의 배열이다. 서술자 종류마다 개별적인 서술자 힙이 필요하다. 또한, 한 종류의 서술자에 대해 여러 개의 힙을 둘 수도 있다. 그리고 하나의 자원에 여러 서술자가 참조하는 것도 가능하다.  마지막으로 서술자들은 응용 프로그램의 초기화 시점에서 생성해야한다. 

### 4.1.7 다중표본화의 이론

 모니터의 픽셀들이 무한히 작지는 않기 때문에, 모니터 화면에 임의의 선을 완벽하게 나타낼 수는 없다. 흔히 계단 현상이라고하는 앨리어싱 효과가 나타나게 되는데 선을 픽셀들의 배열로 근사하다 보면 이런 현상이 발생한다.

 안티앨리어싱 기법을 적용하여 이런 문제를 다소 완화할 수 있다. 이 기법중 하나인 초과표본화(supersampling)는 후면 버퍼와 깊이 버퍼를 화면 해상도보다 4배 크게 잡고, 4배 크기의 해상도에서 후면 버퍼에 렌더링한다. 이미지를 제시할 때가 되면 원래 크기의 버퍼로 환원한다. 하향표본화(downsampling)라고도 불리는 이 환원 공정은 4픽셀 블록의 평균을 그 블로에 해당하는 픽셀의 최종색상으로 사용한다. 본질적으로 초과표본화는 화면 해상도를 소프트웨어에서 증가하는 시키는 것이라 볼 수 있다. 그렇기에 픽셀 처리량과 메모리 소비량이 네 배라서 비용이 높다.

 Direct3D는 다중표본화(multisampling)라는 정축적인 안티앨리어싱 기법을 지원한다. 다중표본화는 일부 계산 결과를 부분픽셀들 사이에서 공유하기에 초과표본화보다 비용이 낮다. 후면 버퍼에 화면 해상도의 4배를 사용하는 것은 동일하지만, 각 부분 픽셀마다 계산하는 것이 아닌 픽셀당 계산하고 그 색상과 부분픽셀들의 가시성과 포괄도를 이용하여 최종색상을 결정한다.

### 4.1.8 Direct3D의 다중표본화

 다중표본화를 위해서는 DXGI_SAMPLE_DESC라는 구조체를 적절히 채워야한다. 이 구조체는 다음과 같이 두 개의 멤버로 이루어져 있다.

```csharp
typedef struct DXGI_SAMPLE_DESC
{
	UINT Count; // 픽셀당 추출할 표본의 개수
	UINT Quality; // 원하는 품질 수준
} DXGI_SAMPLE_DESC;
```

  표본 개수가 많을수록, 품질 수준이 높을수록 렌더링 비용도 증가하므로, 비용과 속도 사이의 절충선을 잘 잡아야 한다. 품질 수준들의 범위는 텍스처 형식과 픽셀당 표본 개수에 의존한다. 

 실제 응용에서는 다중표본화의 성능 및 메모리 비용을 합리적인 수준으로 유지하기 위해 표본을 4개나 8개만 추출하는 경우가 많다. 다중표본화를 사용하고 싶지 않으면 표본 개수를 1로 품질 수준을 0으로 설정하면 된다.

### 4.1.9 기능 수준

 기능 수준(feature level)은 GPU가 지원하는 기능들의 엄격한 집합을 정의한다. 예를 들어 기능 수준 11을 지원하는 GPU는 반드시 Direct3D 11의 기능 집합 전체를 지원해야한다. 현재 GPU의 기능 수준을 파악하기만 하면, 구체적으로 어떤 기능을 사용할 수 있는지 알 수 있기 때문에 프로그램 개발을 편하게 해주는 요인이 된다.

 사용자의 하드웨어가 특정 기능 수준을 지원하지 않는 경우 응용 프로그램이 실행을 아예 포기하는 대신 더 낮은 기능 수준으로 후퇴하는 전략을 사용할 수도 있다. 어느 수준 까지 지원하는지 점검을 하고 순차적으로 내려가는 방식이다.