---
title: "WinAPI : 애니메이션2"
excerpt: "애니메이션 구조와 설계"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-07-21
breadcrumb: true
---

# 39~강. 애니메이션2

저번에는 애니메이션의 기초와 애니메이션을 위한 클래스 구조를 설계해주었다. 이번엔 플레이어의 애니메이션과 프레임 애니메이션을 다룬다.

## 이미지에서 알짜배기만 처리하기

현재 스프라이트는 가운데 실제로 존재하는 부분을 제외하고는 흰색부분으로 처리가 되어있다. 이미지의 알짜배기만 처리하기 위해 콜라이더의 크기를 수동으로 계산해서 처리하고 오브젝트에 이미지 오프셋을 따로 만들어준다. 이미지 오프셋은 오브젝트에서 이미지를 일정 값만큼 띄워놓은 역할을 수행한다.

```csharp
void SetImageOffset(const _SIZE& tOffset)
	{
		m_tImageOffset = tOffset;
	}
void SetImageOffset(float x, float y)
	{
		m_tImageOffset.x = x;
		m_tImageOffset.y = y;
	}
// 위 함수로 오프셋을 설정한다. 기본 값은 구조체 생성자로 (0, 0) 이다.
```

```csharp
if (m_pAnimation)
		{
			PANIMATIONCLIP pClip = m_pAnimation->GetCurrentClip();

			tImagePos.x = pClip->iFrameX * m_tSize.x;
			tImagePos.y = pClip->iFrameY * m_tSize.y;
		}

tImagePos += m_tImageOffset;
```

해당 이미지의 위치를 가져온다음 이미지의 상세 위치를 지정하는 오프셋 값을 추가해주는 것이다. 하지만 해당 정보로는 이미지의 위치가 어긋나게 되므로 FrameSize를 추가하여 한 프레임이 차지하는 픽셀의 크기를 나타내줘야한다. 프레임 크기는 클립 정보에 들어간다.

```csharp
long GetWidth() const
    {
        return m_tInfo.bmWidth;
    }
long GetHeight() const
    {
        return m_tInfo.bmHeight;
    }
```

텍스쳐에서 해당 텍스쳐 이미지의 가로 세로 길이를 받는 함수를 사용하여

```csharp
pClip->tFrameSize.x = pTex->GetWidth() / iFrameMaxX;
	pClip->tFrameSize.y = pTex->GetHeight() / iFrameMaxY;
```

클립 생성 부분에서 받아온다. 프레임 당 사이즈이기 때문에 이미지의 개수로 나누어준다.

```csharp
if (m_pAnimation)
		{
			PANIMATIONCLIP pClip = m_pAnimation->GetCurrentClip();

			tImagePos.x = pClip->iFrameX * pClip->tFrameSize.x;
			tImagePos.y = pClip->iFrameY * pClip->tFrameSize.y;
		}
```

그리고 이미지의 위치를 찾는 부분에서 프레임 사이즈를 통해 위치를 찾아준다.

![/assets/images/posts/2021-07-21/winapi39/winapi39_1.gif](/assets/images/posts/2021-07-21/winapi39/winapi39_1.gif)

이미지의 위치, 충돌체의 크기, 애니메이션 출력이 모두 정상적으로 이뤄지는 것을 확인할 수 있다.

## 분기별 애니메이션

플레이어는 가만히 있거나, 점프를 하거나, 걷거나, 뛸 수도 있다. 이런 움직임을 자연스럽게 표현하기 위해서는 적절한 애니메이션을 출력해줘야한다.

### 달리기(Run)

```csharp
// 달리기 애니메이션
	AddAnimationClip("Run", AT_ATLAS, AO_LOOP, 0.5f, 8, 1,
		0, 0, 8, 1, 0.f, "PlayerRun", L"Player/Run.bmp");
	SetAnimationClipColorKey("Run", 255, 255, 255);
	AddAnimationClip("Run_R", AT_ATLAS, AO_LOOP, 0.5f, 8, 1,
		0, 0, 8, 1, 0.f, "PlayerRun_R", L"Player/Run_R.bmp");
	SetAnimationClipColorKey("Run_R", 255, 255, 255);
```

현재 MoveObj는 입력값에 따라 움직이고 있는지에 대한 여부를 판단가능한 상태이다. 달리기가 끝나면 다시 기본 클립으로 돌아와야하는데 ReturnClip을 사용하여 돌아올 수 있다.

```csharp
void Animation::ReturnClip()
{
	ChangeClip(m_strDefaultClip); //기본 클립으로 변경.
}
```

```csharp
int Player::Update(float fDeltaTime)
{
	MoveObj::Update(fDeltaTime);

	if (!m_bMove)
		m_pAnimation->ReturnClip();

	return 0;
}
```

이동 키를 땠는지에 대한 여부는 업데이트 부분에서 확인할 수 있다.

### 공격

```csharp
//공격 애니메이션
	AddAnimationClip("Attack", AT_ATLAS, AO_ONCE_RETURN, 1.f, 8, 1,
		0, 0, 8, 1, 0.f, "PlayerAttack", L"Player/Attack1.bmp");
	SetAnimationClipColorKey("Attack", 255, 255, 255);
```

하지만 달리기에서 사용한 ReturnClip 때문에 바로 기본 애니메이션으로 돌아오게 된다. 그렇기 때문에 Bool 변수를 하나 두어 공격중임을 나타내야한다.

```csharp
void Player::Fire()
{
	m_bAttack = true;
... // 공격할 때 true로

```

하지만 공격 모션이 끝났음을 전달해야하는 부분이 있어야 다시 변수를 변경할 수 있다. 애니메이션에 MotionEnd라는 변수를 추가해줘서 플레이어에 알려주는 역할을 하도록 한다. 해당 기능은 애니메이션의 Update에서 처리된다.

```csharp
void Animation::Update(float fTime)
{
	m_bMotionEnd = false; // 모션 시작

	m_pCurClip->fAnimationTime += fTime;

	
	while (m_pCurClip->fAnimationTime >= m_pCurClip->fAnimationFrameTime)
	{
		m_pCurClip->fAnimationTime -= m_pCurClip->fAnimationFrameTime;

		//다음 프레임으로 변경.
		++m_pCurClip->iFrameX;

		//만약 현재 프레임이 해당 클립의 프레임 길이와 같다면
		if (m_pCurClip->iFrameX - m_pCurClip->iStartX == m_pCurClip->iLengthX)
		{
			m_pCurClip->iFrameX = m_pCurClip->iStartX; // X축 초기화
			++m_pCurClip->iFrameY; //프레임을 Y축으로 한칸 내린다.
			// 현재 프레임 Y가 프레임 길이 Y와 같다면 한 클립을 다 수행한 것이다.
			if (m_pCurClip->iFrameY - m_pCurClip->iStartY == m_pCurClip->iLengthY)
			{
				// 이 부분이 Motion End
				m_pCurClip->iFrameY = m_pCurClip->iStartY; // Y축 초기화
				m_bMotionEnd = true; // 모션 종료

				//애니메이션 옵션에 따른 수행
				switch (m_pCurClip->eOption)
				{
				case AO_ONCE_RETURN:
					ChangeClip(m_strDefaultClip);
					break;
				case AO_ONCE_DESTROY:
					m_pObj->Die();
					break;
				case AO_TIME_RETURN:
					break;
				case AO_TIME_DESTROY:
					break;
				}
			}
		}
	}

}
```

```csharp
if (m_bAttack && m_pAnimation->GetMotionEnd())
	{
		m_bAttack = false;
	}

if (!m_bMove && !m_bAttack)
	{
		m_pAnimation->ReturnClip();
		SetSize(90.f, 88.f);
		SetImageOffset(70.f, 55.f);
	}
```

공격시 애니메이션의 크기가 다르기 때문에 사이즈와 오프셋을 재설정해줘야한다.

(아직 잘리는 현상 존재)