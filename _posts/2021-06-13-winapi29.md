---
title: "WinAPI : 충돌체 추가 및 충돌 기초 함수"
excerpt: "충돌 오브젝트 관리와 충돌이 어떻게 돌아가는지."
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - WinAPI
tags:
  - [CPP, WinAPI]
date: 2021-06-13
breadcrumb: true
---

# 29강. 충돌체 추가 및 충돌 기초 함수

이전에 충돌체 클래스와 충돌 관리자를 생성해주었다.

게임 오브젝트는 구조상 여러 충돌체를 가지고 있을 수 있다. 충돌체가 있다면 충돌 이벤트가 발생하여야 하는데 이는 반대로 생각해보면 충돌체가 없다면 충돌 처리를 해주지 않아도 되는 것이다.

이제부터 Obj 클래스에 충돌체를 추가하는 템플릿을 추가해주자.

## 충돌체

### 충돌체 추가

충돌체는 자신을 가지고 있는 오브젝트가 어떤 오브젝트인지 기억해야한다.

```csharp
//Collider.h
protected:
	class Obj* m_pObj;

public:
	class Obj* GetObj() const
	{
		return m_pObj;
	}
	void SetObj(class Obj* pObj)
	{
		m_pObj = pObj;
	}
```

오브젝트 변수와 해당 변수의 get, set 함수를 만들어준다.

```csharp
template <typename T>
	T* AddCollider(const string& strTag)
	{
		T* pCollider = new T;

		pCollider->SetObj(this);

		if (!pCollider->Init())
		{
			SAFE_RELEASE(pCollider);
			return NULL;
		}

		pCollider->AddRef();
		m_ColliderList.push_back(pCollider);

		return pCollider;
	}
```

Collider는 Ref를 상속 받기때문에 메모리를 해제해주는 방식로 같게 해줘야한다. 콜라이더에 접근하였으므로 참조 횟수를 늘려주고 오브젝트가 소유하고 있는 충돌체 리스트에 해당 콜라이더를 추가해준다.

### 충돌체가 있는지 확인

충돌체 리스트에 충돌체가 존재하는지 확인해서 해당 오브젝트가 충돌 처리를 해야하는지 판단하는 함수이다.

```csharp
bool CheckCollider()
	{
		return !m_ColliderList.empty();
	}
```

### 충돌체 활성화

오브젝트에서 추가된 충돌체에 대해서 업데이트를 해줘야할 필요가 생긴다.

```csharp
int Obj::Update(float fDeltaTime)
{
	list<Collider*>::iterator iter;
	list<Collider*>::iterator iterEnd = m_ColliderList.end();

	for (iter = m_ColliderList.begin(); iter != iterEnd;)
	{
		// 해당 충돌체가 비활성화 되어있다면 다음 충돌체 확인
		if (!(*iter)->GetEnable())
		{
			++iter;
			continue;
		}
		(*iter)->Update(fDeltaTime);

		// 해당 충돌체가 수명을 다하면
		if (!(*iter)->GetLife())
		{
			// 메모리 해제후 반복자 다시 지정
			SAFE_RELEASE((*iter));
			iter = m_ColliderList.erase(iter);
			iterEnd = m_ColliderList.end();
		}
		else
			++iter;
	}
	return 0;
}
```

해당 형식을 다른 필수 함수들에도 각 함수에 맞게 추가해준다.

## 오브젝트에 충돌체 추가

인게임씬에서 미니언과 총알에 충돌체를 만들어보도록하자.

충돌체를 추가해줄 클래스에 각 충돌체에 대한 헤더를 추가해준다.

```csharp
#include "../Collider/ColliderRect.h"
```

먼저 미니언에 충돌체 추가를 해보겠다. 미니언의 초기화 함수 부분에서 충돌체 추가를 해준다.

```csharp
ColliderRect* pRC = AddCollider<ColliderRect>("Minion");
SAFE_RELEASE(pRC);
```

Rect 충돌할때 필요한 정보로는 좌측 상단, 우측 하단에 대한 좌표 값이 필요하다. 그러므로 ColliderRect는 사각형 정보가 필요하다. 사각형 정보는 담는 Type을 만들어주고 해당 사각형 정보는 복사생성 할때도 사용할 수 있도록 만들어 줘야 한다.

```csharp
// 사각형 정보
typedef struct _tagRectangle
{
	float l;
	float t;
	float r;
	float b;

	_tagRectangle() :
		l(0.f),
		t(0.f),
		r(0.f),
		b(0.f)
	{
	}
		
}RECTANGLE, *PRECTANGLE;
```

```csharp
ColliderRect::ColliderRect(const ColliderRect& coll):
	Collider(coll)
{
	m_tInfo = coll.m_tInfo;
}
```

ColliderRect에서 사각형 정보를 수정할 수 있도록 Set함수를 만들어준다.

```csharp
void ColliderRect::SetRect(float l, float t, float r, float b)
{
	m_tInfo.l = l;
	m_tInfo.t = t;
	m_tInfo.r = r;
	m_tInfo.b = b;
}
```

그리고 오브젝트가 움직이면 충돌체도 따라가야한다. 자신을 가지고 있는 오브젝트가 움직인 만큼 움직여야한다. 오브젝트와의 상대적인 좌표를 잡아주고 Collider의 LateUpdate에서 오브젝트의 이동량을 구한다. 최종적으로는 충돌 처리에 사용할 월드 좌표를 구해줘야한다. 그래서 ColliderRect에는 상대 위치와 최종 위치를 만들어 줘야한다.

```csharp
private:
	RECTANGLE m_tInfo;
	RECTANGLE m_tWorldInfo;

public:
  RECTANGLE GetInfo() const
	{
		return m_tInfo;
	}
	RECTANGLE GetWorldInfo() const
	{
		return m_tWorldInfo;
	}
```

```csharp
int ColliderRect::LateUpdate(float fDeltaTime)
{
	Collider::LateUpdate(fDeltaTime);

	POSITION tPos = m_pObj->GetPos();
	m_tWorldInfo.l = tPos.x + m_tInfo.l;
	m_tWorldInfo.t = tPos.y + m_tInfo.t;
	m_tWorldInfo.r = tPos.x + m_tInfo.r;
	m_tWorldInfo.b = tPos.y + m_tInfo.b;
	return 0;
}
```

현재 미니언의 크기가 100이고 피봇이 (0.5, 0.5)로 잡혀있다. 딱 미니언을 둘러쌀 수 있도록 ColliderRect의 크기를 설정해주자.

```csharp
pRC->SetRect(-50.f, -50.f, 50.f, 50.f);
```

Bullet 쪽도 크기만 변경한 채로 같은 코드를 추가해준다. 

```csharp
ColliderRect* pRC = AddCollider<ColliderRect>("Bullet");
SAFE_RELEASE(pRC);

pRC->SetRect(-25.f, -25.f, 25.f, 25.f);
```

## 충돌매니저에서의 오브젝트 관리

충돌 매니저에서 리스트를 만들고 해당 리스트에 충돌체를 가지고 있는 오브젝트로 채워준다. 

```csharp
void CollisionManager::AddObject(Obj* pObj)
{
	// 충돌체를 가지고 있을때
	if (pObj->CheckCollider())
	{
		m_CollisionList.push_back(pObj);
	}
}
```

레이어에는 Collision 함수가 매 실행마다 들어온다. 비활성화 되어있거나 지운 오브젝트는 넣을 필요가 없다. 레이어에서 충돌 함수에 대해 아래와 같이 처리해준다.

```csharp
//Layer.cpp - Collision 함수
else // 지워지지않고 활성화된 오브젝트
		{
			GET_SINGLE(CollisionManager)->AddObject(*iter);
			++iter;
		}
```

이러면 특수한 상황을 제외한 모든 오브젝트가 CollisionList에 들어가게 된다.

Core에서 장면 관리자의 충돌 함수가 실행되고 나서 충돌 관리자의 충돌 함수가 실행되도록 만든다.

```csharp
void Core::Collision(float fDeltaTime)
{
    GET_SINGLE(SceneManager)->Collision(fDeltaTime);
    GET_SINGLE(CollisionManager)->Collision(fDeltaTime);
}
```

충돌 관리자의 충돌 함수는 다음과 같다.

```csharp
void CollisionManager::Collision(float fDeltaTIme)
{
	if (m_CollisionList.size() < 2)
	{
		m_CollisionList.clear();
		return;
	}
	// 오브젝트간 충돌처리를 한다.
}
```

충돌 오브젝트가 2개이상 존재하지 않으면 매 프레임마다 리스트를 비워주고 존재할 경우 만들어 놓은 충돌처리를 실행하도록 한다.